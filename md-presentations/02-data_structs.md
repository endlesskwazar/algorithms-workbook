# Базові структури даних і операції над ними



## Структури даних


### Структури даних

**Структура даних** (англ. Data structure) - програмна одиниця, що дозволяє зберігати і обробляти безліч однотипних і, або логічно пов'язаних даних в обчислювальній техніці. Для додавання, пошуку, зміни і видалення даних структура даних надає певний набір функцій, з яких складається інтерфейс.



## Масив


### Масив

**Масив** - це область пам'яті, де можуть послідовно зберігатися кілька значень.

![](../resources/img/basic_data_struct/img-4.png)

- Масив надає константий доступ по індексу
- Мисив в пам'яті зберігається безперервно
- Масив має фіксований розмір, після ініціалізаії(виділення)


### Аналіз складності додавання елементу в масив

**Додавання елементу в в кінець масиву** займає константиний час O(1). 

![](../resources/img/basic_data_struct/img-8.png)


### Аналіз складності додавання елементу в масив

Для того щоб додати елемент в початок або в довільне місце доведеться потратити O(n), тому що нам доведеться здвигати n елементів для того щоб звільнити місце під новий елемент:

![](../resources/img/basic_data_struct/img-9.png)


### Аналіз складності видалення елементу із масиву

**Видалення елементу із кінця масиву** відбувається за констаний час - O(1). За адресою останнього елемента його можна видалити. Навіть, необов'язково затирати останній елемент, можна просто ставити до нового дійсного розміру масива як до size - 1


### Аналіз складності видалення елементу із масиву

Для того щоб видалити елемент з початку або довільного місця доведеться виконати O(n) операцій. Саме видалення елемента константе, але після його видалення в масиві з'явиться дира:

![](../resources/img/basic_data_struct/img-10.png)


### Асимптотичні складності операцій з масивом

||Додавання|Видалення|
|-|-|-|
|Початок|O(n)|O(n)|
|Кінець|O(1)|O(1)|
|Середина|O(n)|O(n)|



## Динамічний масив


### Динамічний масив

**Динамічним** називається масив, розмір якого може змінюватися під час виконання програми. Можливість зміни розміру відрізняє динамічний масив від статичного, розмір якого задається на момент компіляції програми.

![](../resources/img/basic_data_struct/img-1.jpg)


### Динамічний масив

ля масивів з можливістю динамічної зміни розміру при реалізації доводиться знаходити «золоту середину» між кількома суперечливими вимогами:

- Ефективність по пам'яті - реалізація не повинна приводити до великої перевитрати пам'яті.
- Ефективність по продуктивності, яка включає в себе:
  - мінімальні накладні витрати на зміну розміру масиву;
  - збереження, по можливості, константного часу доступу на читання / запис до елементів масиву.
- Сумісність зі звичайними статичними масивами на низькому рівні.


### Динамічний масив

Динамічні масиви можуть підтримуватися або на рівні синтаксису самої мови програмування, або на рівні системних бібліотек.


### Динамічний масив

```cpp
int *mas = (int*)malloc(sizeof(int) * n);
...
mas = (int*)realloc(mas, sizeof(int) * m); // Зміна розміру з m на n із збереженням вмісту масиву
...
free(mas); 
```

Незручність такого підходу полягає в необхідності обчислювати розміри виділеної пам'яті, застосовувати явне перетворення типу і ретельно відслідковувати час життя масиву (як і завжди при роботі з динамічно виділеною пам'яттю в С).


### Динамічний масив

При реалізації динамічного масиву потрібно розглянути два способи збільшення розміру нового масиву:

- Аддитивний. Перевиділення па'яті пов'язане із додаванням константи до даного розміру масиву
- Мультиплікативний. Перевиділення пам'яті пов'язане із множенням на контсанту даного розміру масиву


### Динамічний масив

![](../resources/img/basic_data_struct/img-3.png)


### Реалізація динамічного масиву на C++

workbook code


### Реалізація динамічного масиву на C++

![](../resources/img/basic_data_struct/img-2.png)


### std::vector

В стандартній бібліотеці C ++ є поліпшена версія динамічних масивів, більш безпечна і зручна - std :: vector.

Представлений в C ++ 03, std :: vector (або просто вектор) - це той же динамічний масив, але який може сам керувати виділеної собі пам'яттю. Це означає, що ви можете створювати масиви, довжина яких задається під час виконання, без використання операторів new і delete (явного вказівки виділення і звільнення пам'яті). std :: vector знаходиться в заголовки &lt;vector&gt;.


### std::vector

Оголошення std::vector наступні:
```cpp
#include <vector>
// немає необхідності вказувати довжину при ініціалізації
std :: vector <int> array;
std :: vector <int> array2 = {10, 8, 6, 4, 2, 1}; // використовується список ініціалізаторів для ініціалізації масиву
std :: vector <int> array3 {10, 8, 6, 4, 2, 1}; // використовується uniform ініціалізація для ініціалізації масиву (починаючи з C ++ 11)
```
Зверніть увагу, що і в неініціалізованих, що і в Ініціалізувати випадках вам не потрібно явно вказувати довжину array. Це пов'язано з тим, що std :: vector динамічно виділяє пам'ять для свого вмісту за запитом.


### srd::vector
Подібно std :: array, доступ до елементів масиву може виконуватися як через оператор [] (який не виконує перевірку діапазону), так і через функцію at () (яка виконує перевірку діапазону):

```cpp
array [7] = 3; // без перевірки діапазону
array.at (8) = 4; // з перевіркою діапазону
```


### srd::vector
Починаючи з C ++ 11, ви також можете присвоювати значення std :: vector використовуючи список ініціалізаторів:

```cpp
array = {0, 2, 4, 5, 7}; // добре, довжина array тепер 5
array = {11, 9, 5}; // добре, довжина array тепер 3
```


### std::vector і memory leek

```cpp
void doSomething (bool value)
{
    int * array = new int [7] {12, 10, 8, 6, 4, 2, 1};
    if (value)
        return;
   // робимо що-небудь
    delete [] array; // ніколи не виконається
}
```
Якщо value задати значення true, то array ніколи не буде віддалятися, пам'ять ніколи не буде звільнятися і станеться витік пам'яті.
Однак, якби array був вектором, то подібне ніколи б не сталося, так як пам'ять звільнялася б автоматично, як тільки array вийшов би з області видимості (незалежно від того, чи вийде функція раніше з області видимості чи ні). Саме через це використання std :: vector є більш безпечним, ніж динамічне виділення пам'яті через оператор new.


### Довжина вектора

На відміну від стандартних динамічних масивів, які не знають свою довжину, std :: vector свою довжину запам'ятовує. Щоб її дізнатися - потрібно використовувати функцію size ():

```cpp
#include <vector>
#include <iostream>
 
int main ()
{
    std :: vector <int> array {12, 10, 8, 6, 4, 2, 1};
    std :: cout << "The length is:" << array.size () << '\ n';
 
    return 0;
}
```


### Зміна розміру вектора

Змінити розмір стандартного динамічно виділеного масиву досить проблематично і складно. Змінити розмір std :: vector так само просто, як викликати функцію resize ():

```cpp
#include <vector>
#include <iostream>
 
int main ()
{
    std :: vector <int> array {0, 1, 2};
    array.resize (7); // змінюємо довжину array на 7
 
    std :: cout << "The length is:" << array.size () << '\ n';
 
    for (auto const & element: array)
        std :: cout << element << '';
 
    return 0;
}
```


### Зміна розміру вектора
Розмір вектора також можна змінити і в зворотний бік (обрізати):

```cpp
#include <vector>
#include <iostream>
 
int main ()
{
    std :: vector <int> array {0, 1, 4, 7, 9, 11};
    array.resize (4); // змінюємо довжину array на 4
 
    std :: cout << "The length is:" << array.size () << '\ n';
 
    for (auto const & element: array)
        std :: cout << element << '';
 
    return 0;
}
```



## Списки


### Списки

**Зв'язаний список** - базова динамічна структура даних в інформатиці, що складається з вузлів, кожен з яких містить як власне дані, так і одну або дві посилання ( «зв'язки») на наступний і, або попередній вузол списку. Важлива перевага перед масивом є структурна гнучкість: порядок елементів зв'язкового списку може не збігатися з порядком розташування елементів даних в пам'яті комп'ютера, а порядок обходу списку завжди явно задається його внутрішніми зв'язками.


### Однозв'язний список

Кожен вузол ононаправленого (однозв'язного) лінійного списку містить одне поле покажчика на наступний вузол. Поле покажчика останнього вузла містить нульове значення (вказує на NULL або TAIL).

![](../resources/img/basic_data_struct/img-5.png)


### Однозв'язний список

Давйте опустимо елементи HEAD і TAIL, а також те що крім даних ми зберігаємо ше і показчик на наступний елемент. Хоча, не будемо забувати про їх існування.

![](../resources/img/basic_data_struct/img-6.png)


### Додавання елементу в список

**Вставка в кінець** списку виконується за $O(1)$:

![](../resources/img/basic_data_struct/img-16.png)


### Додавання елементу в список
**Вставка в початок** списку теж доволі проста операція, яка виконується за константний час:

![](../resources/img/basic_data_struct/img-17.png)


### Додавання елементу в список
Під **вставкой в середину** ми розуміємо вставку після, якогось елементу або до. Якщо розглядати **вставку після якогось елементу** це робиться за константний час:

![](../resources/img/basic_data_struct/img-18.png)

Якщо нам потрібно **додати елемент перед даним**, то нам потрібно потратити $O(n)$ для того, щоб знайти елент в спискові в якого показчик веде на даний елемент.


### Видалення елементу із списка

**Видалення із початку** виконується за $O(1)$:

![](../resources/img/basic_data_struct/img-19.png)


### Видалення елементу із списка
**Видалення із кінця** займе $O(n)$. Тому що доведеться пройти весь список, щоб знайти елемент показчик, якого посилається на TAIL.

**Видалення із середини** буде працювати за $O(n)$, зновуж таки ми не знаємо попередній елемент, і щоб його знайти доведеться проходити по спискові.


### Реалізація однозв'язного списку на C++

```cpp
#include <iostream>
using namespace std;
struct Node {
    int data;
    struct Node *next;
};
struct Node* head = NULL;
void insert(int new_data) {
    struct Node* new_node = (struct Node*) malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = head;
    head = new_node;
}
void display() {
    struct Node* ptr;
    ptr = head;
    while (ptr != NULL) {
        cout<< ptr->data <<" ";
        ptr = ptr->next;
    }
}
int main() {
    insert(3);
    insert(1);
    insert(7);
    insert(2);
    insert(9);
    cout<<"The linked list is: ";
    display();
    return 0;
}
```


### std::forward_list

**Forward list** - контейнер, що надає механізм вставки і видалення елементів з контейнера. Швидкий довільний доступ не підтримується. Реалізований у вигляді односпрямованого списку.


### std::forward_list

|Метод|Пояснення|
|-|-|
|front()|Доступ до першого елемента|
|empty()|Перевіряє наявність елементів|
|clear()|Очищення контейнера|
|insert_after()|Вставка після елементу|
|push_front()|Додає елемент в початок списку|
|pop_front()|Видаляє елемент із початку списку|


### std::forward_list
```cpp
#include <iostream>
#include <forward_list>
 
int main()
{
    std::forward_list<int> numbers = { 1, 2, 3, 4, 5 };
 
    int first = numbers.front();    // 1
 
    for (int n : numbers)
        std::cout << n << "\t";
    std::cout << std::endl;
    return 0;
}
```


### Двохзв'язний список
Кожен вузол двонаправленого (двохзвёязного) лінійного списку містить два поля покажчиків - на наступний і на попередній вузли. Покажчик на попередній вузол кореня списку містить нульове значення. Покажчик на наступний вузол останнього вузла також містить нульове значення.

![](../resources/img/basic_data_struct/img-7.png)


### одно vs двохзв'язний
||Однозв'язний|Двохзв'язний|
|-|-|-|
|Вставка в початок|$O(1)$|$O(1)$|
|Вставка в кінець|$O(1)$|$O(1)$|
|Вставка в середину|$O(n)$|$O(1)$|
|Видалення із початку|$O(1)$|$O(1)$|
|Видалення із кінця|$O(n)$|$O(1)$|
|Видалення із середини|$O(n)$|$O(1)$|
|Доступ до елемента|$O(n)$|$O(n)$|
|Пошук|$O(n)$|$O(n)$|


### std::list
std::list являє собою контейнер, який підтримує швидку вставку і видалення елементів з будь-якої позиції в контейнері. Швидкий довільний доступ не підтримується. Він реалізований у вигляді двусвязного списку. На відміну від std :: forward_list цей контейнер забезпечує можливість двонаправленого ітерування, будучи при цьому менш ефективним щодо використовуваної пам'яті.



## Стек


### Стек
Стек - це колекція, елементи якої отримуються за принципом «останній увійшов, перший вийшов» (Last-In-First-Out або LIFO). Це означає, що ми будемо мати доступ тільки до останнього доданому елементу.

![](../resources/img/basic_data_struct/img-11.png)


### Стек
Стек - це абстрактна структура даних, яка характеризується наступним інтерфейсом:

- **empty** - перевірка на наявність елементів
- **push** - додавання елементу на вершину стека
- **pop** - повернення і видалення елементу із вершини стека
- peek - отримання елементу із стека, але без видалення
- count - кількість елементів в стекові


### Стек
Де використовується структура даних - Стек:

- Для зберігання переданих параметрів у функцію
- Для рекурсивних викликів
- Для виконання програмних операції((A+B)*(C+D))


### Представлення на масиві
Перед реалізацією стека виділимо ключові поля:
- s[1...n] - масив, який здатен вмістити не більше n - елементів
- s.top - індекс останнього елемента в масиві

Стек складається з елементів s [1 ... s.top], де s [1] - елемент на дні стека, а s [s.top] - елемент на його вершині. Якщо s.top = 0, то стек не містить жодного елемента і є порожнім.


### На динамічному масиві
Можлива реалізація стека на динамічному масиві, в результаті чого з'являється істотна перевага над звичайною реалізацією: при операції push ми ніколи не зможемо вийти за межі масиву, тим самим уникнемо помилки виконання.


### З використанням списку
тек можна реалізувати і на списку. Для цього необхідно створити список і операції роботи стека на створеному списку. Нижче представлений приклад стека на однозв'язного списку.

![](../resources/img/basic_data_struct/img-3.gif)


### З використанням списку
```cpp
#include <iostream>
using namespace std; 
int stack[100], n=100, top=-1;
void push(int val) {
   if(top>=n-1)
      cout << "Stack Overflow" << endl; 
   else {
      top++;
      stack[top]=val;
   }
}
void pop() {
   if(top<=-1)
      cout << "Stack Underflow" << endl;
   else {
      cout << "The popped element is " << stack[top] << endl;
      top--;
   }
}
```


### std::stack
Клас є контейнером-адаптером, що дає програмісту функціональність стека - зокрема, FILO (First In Last Out - перший увійшов, останній вийшов) структури даних.


### std::stack
|Метод|Пояснення|
|-|-|
|top()|Доступ до вершини стека без його видалення|
|empty()|Перевіряє наявність елементів|
|push()|Додає елемент на вершину стека|
|pop()|Повертає і видаляє елемент із вершини стека|
|push_front()|Додає елемент в початок списку|
|pop_front()|Видаляє елемент із початку списку|


### std::stack
```cpp
#include <iostream> 
#include <stack> 
using namespace std; 
  
void showstack(stack &lt;int&gt; s) 
{ 
    while (!s.empty()) 
    { 
        cout << '\t' << s.top(); 
        s.pop(); 
    } 
    cout << '\n'; 
} 
  
int main () 
{ 
    stack &lt;int&gt; s; 
    s.push(10); 
    s.push(30); 
    s.push(20); 
    s.push(5); 
    s.push(1); 
  
    cout << "The stack is : "; 
    showstack(s); 
  
    cout << "\ns.size() : " << s.size(); 
    cout << "\ns.top() : " << s.top(); 
  
  
    cout << "\ns.pop() : "; 
    s.pop(); 
    showstack(s); 
  
    return 0; 
} 
```



## Знаходження макимального/мінімального елементу в стекові за константний час


### Знаходження макимального/мінімального елементу в стекові за константний час

Підтримувати мінімальний або максимальний елемент в стекові можна за допомогою іншого стека, який буде зберігати відповідно мінімальне або максимальне значення при додаванні елементу:


### 

![](../resources/img/basic_data_struct/img-14.png)


### Знаходження макимального/мінімального елементу в стекові за константний час

```
Процедура getMax:
    повернути S2.pop()

Прооцедура push(x):
    Якщо S1 порожній
        S1.push(x)
        S2.push(x)
    Інакше
        Якщо x > S2.top()
            S1.push(x)
            S2.push(S2.top())
        Інакше
            S1.push(x)
            S2.push(x)
```
q



## Черга


### Черга
Черга (англ. queue) в програмуванні — динамічна структура даних, що працює за принципом «перший прийшов — перший пішов» (англ. FIFO — first in, first out).

![](../resources/img/basic_data_struct/img-12.png)


### Черга
Основні операції із чергою:
- **enqueue** — "поставити в чергу". Операція додавання елемента в "хвіст" черги. При цьому довжина черги збільшується на одиницю. Якщо відбувається намагання додати елемент у вже заповнену чергу, відбувається її переповнення (англ. queue overflow).
- **dequeue** — "отримання з черги". Операція, яка повертає елемент з голови та видаляє його з черги, таким чином встановлюючи голову на наступний за видаленим елемент та зменшуючи довжину на одиницю. При намаганні видалити елемент з пустої черги, виникає ситуація "незаповнення" (англ. queue underflow).


### Релізація на масиві

Перший спосіб являє чергу у вигляді масиву і двох цілочисельних змінних start і end.

![](../resources/img/basic_data_struct/img-1.gif)


### Релізація на масиві

![](../resources/img/basic_data_struct/img-2.gif)


### Релізація на масиві
- **Переваги даного методу**: можлива незначна економія пам'яті в порівнянні із списками; простіше в розробці.
- **Недоліки**: максимальна кількість елементів в черзі обмежена розміром масиву. При його переповненні потрібно перевиделення пам'яті і копіювання всіх елементів в новий масив.


### Реалізація на спискові
Другий спосіб заснований на роботі з динамічною пам'яттю. Черга представляється як лінійний список, в якому додавання / видалення елементів йде строго з відповідних його кінців.
**Переваги даного методу**: розмір черги обмежений лише обсягом пам'яті.
**Недоліки**: складніше в розробці; потрібно більше пам'яті; при роботі з такою чергою пам'ять сильніше фрагментируется; робота з чергою дещо повільніше.


### Реалізація на двох стеках
Методи черзі можуть бути реалізовані на основі двох стеків $S_1$ і $S_2$, як показано нижче:

```
Процедура enqueue (x):
    S1.push (x)

Функція dequeue ():
    якщо S2 порожній:
        якщо S1 порожній:
            повідомити про помилку: черга порожня
        поки S1 не пустили:
            S2.push (S1.pop ())
    повернути S2.pop ()
```


### Реалізація на двох стеках
![](../resources/img/basic_data_struct/img-13.png)

Такий спосіб реалізації найбільш зручний в якості основи для побудови персистентной черзі


### std:queue

**Клас std::queue** є контейнерним адаптером, який дає програмісту функціональність черги - зокрема, FIFO (першим увійшов, першим вийшов) структуру даних.


### std:queue
|Метод|Пояснення|
|-|-|
|front()|Доступ першого елементу|
|back()|предоставляє доступ до останнього елемента|
|empty()|Перевіряє наявність елементів|
|pop()|Повертає і видаляє перший елемент|
|push()|Вставляє елемент в кінець|


### std:queue
```cpp
#include <iostream> 
#include <queue> 
  
using namespace std; 
  
void showq(queue &lt;int&gt; gq) 
{ 
    queue &lt;int&gt; g = gq; 
    while (!g.empty()) 
    { 
        cout << '\t' << g.front(); 
        g.pop(); 
    } 
    cout << '\n'; 
} 
  
int main() 
{ 
    queue &lt;int&gt; gquiz; 
    gquiz.push(10); 
    gquiz.push(20); 
    gquiz.push(30); 
  
    cout << "The queue gquiz is : "; 
    showq(gquiz); 
  
    cout << "\ngquiz.size() : " << gquiz.size(); 
    cout << "\ngquiz.front() : " << gquiz.front(); 
    cout << "\ngquiz.back() : " << gquiz.back(); 
  
    cout << "\ngquiz.pop() : "; 
    gquiz.pop(); 
    showq(gquiz); 
  
    return 0; 
} 
```
q

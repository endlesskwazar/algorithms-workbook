# Черга із пріорітетом. Двійкова куча

# Зміст

${toc}

# Черга із пріорітетом

**Черга з пріоритетом** (англ. Priority queue) - абстрактний тип даних в програмуванні, що підтримує дві обов'язкові операції - додати елемент і отримати максимум (мінімум). Передбачається, що для кожного елемента можна обчислити його пріоритет - дійсне число або в загальному випадку елемент лінійно впорядкованої множини.

Основні методи, які реалізуються чергою з пріоритетом, такі:

- insert (ключ, значення) - додає пару (ключ, значення) в сховище;
- extract_maximum () - повертає пару (ключ, значення) з мінімальним значенням ключа, видаляючи її з сховища.

На практиці інтерфейс черзі з пріоритетом нерідко розширюють іншими операціями:
- findMin или findMax — пошук елемента із найбільшим пріорітетом
- deleteMin(), deleteMax(), deleteKey() - видалення елемента із певним пріорітетом
- increaseKey або decreaseKey - оновити значення елемента

Приклади застосування черги із пріорітетом:
- Планувальник задач передачі даних:
Максимально можливу кількість черг чотири: High, Medium, Normal, Low. Планувальник починає обслуговування з більш пріоритетною черзі High. Якщо в її черги більше немає очікують пакетів, то він переходить до наступної менш пріоритетною черзі в якій є очікують пакети. Після кожного обслуговування черг Medium, Normal або Low планувальник повертається до черги High, тобто процес повторюється. Низько-пріоритетна чергу Low обслуговується тільки коли в чергах High, Medium, Normal немає очікують пакетів.

# Наївні реалізації черги із пріорітетом

||Insert|ExtractMax|
|-|-|-|
|Масив/список|$O(1)$|$O(n)$|
|Упорядкований масив/список|O(n)|O(1)|

# Двійкова куча

Двійкова куча, піраміда, або сортувальне дерево - таке бінарне дерево, для якого виконані три умови:

- Значення в будь-якій вершині не менш, ніж значення її нащадків.
- Глибина всього листя (відстань до кореня) відрізняється не більше ніж на 1 шар.
- Останній шар заповнюється зліва направо без «дірок».

Існують також кучі, де значення в будь-якій вершині, навпаки, не більше, ніж значення її нащадків. Такі купи називаються min-heap, а кучі, описані вище - max-heap.

![](../resources/img/heap/img-1.png)

## Операції

### GetMax

Реалізація GetMax просто повертає корінь дерева. Операція GetMax працює за $O(1)$

### Insert

### ExtractMax

### ChangePriority

### Remove

## Повністю заповнена двійкова куча

### Як  підтримувати дерево повністю заповненим?

## Реалізація двійкової кучі



# Пірамідальне сортування(Heap sort)

## Переваги і недоліки heap sort

Переваги:
- Має доведену оцінку гіршого випадку $O(nlog n)$.
- Сортує на місці, тобто вимагає всього $O(1)$ додаткової пам'яті

Недостатки:

- Нестійкий
- На майже відсортованих масивах працює так само довго, як і на хаотичних даних.
- На одному кроці вибірку доводиться робити хаотично по всій довжині масиву - тому алгоритм погано поєднується з кешуванням і підкачкою пам'яті.
- Методу потрібно «миттєвий» прямий доступ; не працює на пов'язаних списках і інших структурах пам'яті послідовного доступу.

Heap sort активно використовується в ядрі [лінукс](https://elixir.bootlin.com/linux/latest/source/lib/sort.c)

# STL priority_queue

# Домашнє завдання

Реалізуйте двійкову кучу.

# Контрольні запитання

1. Що таке черга із пріорітетом?
2. Назвіть наївні реалізації черги із пріорітетом?
3. Що таке двійкова куча?
4. Навіщо двійкова куча повинна бути повністю заповнена?
5. Як підтримувати повністю заповнену двійкову кучу
6. Поясніть принцип пірамідального сортування.